---
layout: default
title:  "Coding an hashmap from scratch... in webassembly"
description: "Why I wanted to develop an hashmap in webassembly."

authors: ["Adrien Zinger"]
comments_id: 9
---

# Coding a hashmap from scratch... in webassembly
<span style="color: #A0A0A0">[2022-05-18] \#WASM \#DataStructure

---


At first, it's strange and useless. I'm aware of that, the goal is not
to replace the data structures generated by *C*, *AssemblyScript*, *grain* or
whatever an higher level language that build to wasm. It's something
you should do if you want to really understand what's happening when you want
at some point do interoperability.

## First, some words about webassembly

Webassembly begins to be famous in the planet *informatic*. Nevertheless,
all use-cases where you consider to build a wasm require some kind of embedder.
In other words, you need to define an environment to execute your code using
another language. E.g. *nodejs*, *Rust* or at least a browser that support wasm!

> Here is a list of
> <a href="https://github.com/appcypher/awesome-wasm-runtimes" style="color: inherit !important;">
> awesome wasm runtimes</a>

Once your done, you need to define how you manage the discussion between the
embedder (runtime) and the wasm instance.

```js
(module
  (func $add (param $lhs i32) (param $rhs i32) (result i32)
    local.get $lhs
    local.get $rhs
    i32.add)
  (export "add" (func $add))
)
```

```js
WebAssembly.instantiateStreaming(fetch('add.wasm'))
.then(obj => {
    console.log(obj.instance.exports.add(1, 2));  // "3"
});
```

Here, we learn how to pass a simple `i32`. And then? What about a string? A
user-defined structure? The web seems to silent the fact that there is no
convention about it...

There is some good stuff that can help you if you work with
*Rust* that build to *wasm* and if you use the wasm in *Rust*.🐍
[wasm-bingen](https://github.com/rustwasm/wasm-bindgen) is a good example of
a project that tend to unify everybody. But it's not very flexible for now.

In conclusion, if you want some exotic stuff with wasm, you have to learn by
yourself how the data is represented in memory. And if you don't want to drown, I
strongly recommend to you to learn and write in webassembly directly. (That's very
fun!)

> Have a look at another of my post about string concatenation
> <a href="https://www.maybeuninit.com/2022/05/31/concat-wasm.html" style="color: inherit !important;">
> here</a>. I speak about reading
> and writing in an instance's memory.

## The insert method

The map I build in memory has a classic memory representation. First I
choose to create a map of 256 elements. And each of these element is a
32-bits address pointing to a list of elements, initialized to `0`.

```sh
|-----    256    -----|
v                     v
+--+--+--+--+-.-+--+--+
| 0| 0| 0| 0| . | 0| 0|
+--+--+--+--+-.-+--+--+
```

The first thing I need to do is to check if there is something in the
map for my key, so basically I search the address of an item and
if the address is the impossible value `0`, it means that there is
no `key` in my map, so in the head of the list pointed by node I push
a new item.

```js
 (func $insert (param $map i32) (param $key i32) (param $val i32)
        (local $addr i32)
        (local $item i32)
	local.get $map
	local.get $key
	call $internal/get_item_addr
	local.tee $addr
	i32.eqz
	(if
  	  (then
	    local.get $map
	    local.get $key
	    call $internal/get_key_addr    // Addr in the map
	    local.tee $addr

	    local.get $key
	    local.get $val
	    local.get $addr                // Addr contains the current head pointer
	    i32.load                       // Load the pointer
	    call $internal/new_item        // Creates an item pointing to the previous
	                                   //             head and returns his address
	    i32.store                      // Replace the old address by the new in the map
	  )
	  (else                            // Simply replace the old value at the offset 32
	                                   // with the new value.
	    local.get $addr
	    i32.const 32
	    i32.add
	    local.get $val
	    i32.store
	  )
	)
 )
)
```

## Get an item

The function `$internal/get_key_addr` used in the previous don't just
looks at the address pointed by the key hash on my map. But it looks through
an array-list if my key is stored. It's maybe something you didn't get
before but a map is'nt simply `Θ(1)` in any cases. It could be if the map
had an infinite size. Unfortunately, it's impossible.

I let you look at my favorite scientific website for more information
about *hash table*, wikipedia.

1. Get the address of the head (in my map)
2. Search in the array-list the key
3. Return the address where the value is stored, or `0`

```js
(func $internal/find (param $addr i32) (param $key i32) (result i32)
	local.get $addr
	i32.eqz
	(if (then                // early return if address is 0
	   i32.const 0
	   return
	))
	local.get $addr
	i32.load                 // load key, require kv addr on
	                         //  the stack
	local.get $key
	i32.eq
	(if (result i32)
	  (then local.get $addr) // found! break the recursion and return
	                         //  the address

	  (else                  // go to next addr and repeat
	    local.get $addr
	    i32.const 64
	    i32.add
	    i32.load
	    local.get $key
	    call $internal/find
	  )
	)
 )
```

## Where I cheat

I cheat a little bit, because I only accept `i32` as keys and values. My
hashing function is a simple hash by division. And I don't think about the
free of all of this. I'll implement that stuff later! 😂

Anyway, that was very fun, I you want to look at the full code and how I
use it in a *JS* environment, have a look at the sources
[here](https://github.com/adrien-zinger/code_bucket/tree/main/hashmap_wasm).

